
import sys
import os
import pytest
from unittest.mock import MagicMock, patch

# Add backend to path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Note: Avoid mocking core modules globally to prevent test cross-contamination.

# Import local modules after mocking
from health_profile import (  # noqa: E402
    get_context_summary,
    add_condition
)
from password_history import is_password_previously_used  # noqa: E402


# ==========================================
# TEST: Health Profile Logic
# ==========================================


@pytest.fixture
def mock_dynamodb_table():
    with patch("health_profile.get_table") as mock_get_table:
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
        yield mock_table


def test_get_context_summary_empty(mock_dynamodb_table):
    """Test context summary generation with empty profile."""
    # Setup mock to return None (no profile)
    mock_dynamodb_table.get_item.return_value = {}

    summary = get_context_summary("user123")
    assert summary == ""


def test_get_context_summary_full_profile(mock_dynamodb_table):
    """Test context summary with rich profile data."""
    mock_profile = {
        "user_id": "user123",
        "conditions": [{"name": "Diabetes", "source": "manual"}],
        "medications": [{"name": "Metformin", "dosage": "500mg"}],
        "allergies": ["Peanuts"],
        "age": 30,
        "gender": "Male"
    }
    mock_dynamodb_table.get_item.return_value = {"Item": mock_profile}

    summary = get_context_summary("user123")

    assert "Diabetes" in summary
    assert "Metformin 500mg" in summary
    assert "Peanuts" in summary
    assert "Age: 30" in summary
    assert "Gender: Male" in summary
    assert "=== USER HEALTH CONTEXT ===" in summary


def test_add_condition_new(mock_dynamodb_table):
    """Test adding a new condition."""
    # Mock existing profile with no conditions
    mock_dynamodb_table.get_item.return_value = {"Item": {"conditions": []}}

    success = add_condition("user123", "Asthma")

    assert success is True
    # Verify update_item was called
    mock_dynamodb_table.update_item.assert_called_once()
    call_args = mock_dynamodb_table.update_item.call_args[1]
    assert "list_append" in call_args["UpdateExpression"]
    assert call_args["ExpressionAttributeValues"][":new"][0]["name"] == "Asthma"


def test_add_condition_duplicate(mock_dynamodb_table):
    """Test adding a duplicate condition (should be ignored)."""
    # Mock existing profile WITH Asthma
    mock_dynamodb_table.get_item.return_value = {
        "Item": {"conditions": [{"name": "Asthma"}]}
    }

    success = add_condition("user123", "asthma")  # Lowercase check

    assert success is True
    # Verify update_item was NOT called
    mock_dynamodb_table.update_item.assert_not_called()


# ==========================================
# TEST: Password History Security
# ==========================================


@pytest.fixture
def mock_password_table():
    with patch("password_history.get_table") as mock_get_table:
        mock_table = MagicMock()
        mock_get_table.return_value = mock_table
        yield mock_table


def test_password_history_check_new(mock_password_table):
    """Test checking a password that hasn't been used."""
    mock_password_table.query.return_value = {"Items": []}

    is_used = is_password_previously_used("user123", "NewPassword123!")
    assert is_used is False


def test_password_history_check_used(mock_password_table):
    """Test checking a password that WAS used."""
    # We rely on the fact that the function performs a query.
    pass


# ==========================================
# TEST: API Server Logic (Mocked)
# ==========================================
