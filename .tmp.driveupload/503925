"""
Unit tests for api_server.py - FastAPI endpoint tests.
Uses TestClient with mocked dependencies.
"""

from unittest.mock import patch
import base64
from fastapi.testclient import TestClient


# Set up environment before importing the app
import os
os.environ.setdefault("GOOGLE_API_KEY", "test-api-key")
os.environ.setdefault("ENVIRONMENT", "test")
os.environ.setdefault("COGNITO_USER_POOL_ID", "us-east-1_test123")
os.environ.setdefault("COGNITO_CLIENT_ID", "test-client-id")


class TestHealthEndpoint:
    """Tests for /health endpoint."""

    def test_health_returns_200(self):
        """Test that health endpoint returns 200 status."""
        from api_server import app
        client = TestClient(app)

        response = client.get("/health")

        assert response.status_code == 200

    def test_health_returns_model_info(self):
        """Test that health endpoint returns model information."""
        from api_server import app
        client = TestClient(app)

        response = client.get("/health")
        data = response.json()

        assert "model" in data
        assert "version" in data
        assert "status" in data

    def test_health_returns_ok_status(self):
        """Test that health returns OK status."""
        from api_server import app
        client = TestClient(app)

        response = client.get("/health")
        data = response.json()

        assert data["status"] == "healthy"

    def test_verify_auth_requires_authorization(self):
        """Test that verify endpoint handles missing authorization."""
        from api_server import app
        client = TestClient(app)

        response = client.get("/auth/verify")

        assert response.status_code == 200
        assert response.json()["authenticated"] is False

    def test_chat_returns_response_for_valid_query(self):
        """Test that chat returns response for valid query."""
        from api_server import app

        mock_answer = "Here is some medical advice..."

        # Patching the new functions used in api_server.chat
        with patch("api_server.check_input_safety") as mock_safety, \
             patch("api_server.check_output_safety") as mock_output_safety, \
             patch("api_server.invoke_llm") as mock_llm, \
             patch("api_server.extract_treatment_steps") as mock_steps, \
             patch("api_server.detect_medical_topic") as mock_topic, \
             patch("api_server.generate_all_step_images") as mock_images, \
             patch("api_server.check_guest_limit") as mock_check_guest, \
             patch("api_server.increment_guest_message") as mock_increment_guest, \
             patch("api_server.log_guest_event") as mock_log_guest:

            mock_safety.return_value = (True, "How to treat a headache?", None)
            mock_output_safety.return_value = (True, mock_answer, None)
            mock_llm.return_value = mock_answer
            mock_steps.return_value = [{"step_number": "1", "title": "Step 1", "description": "Do this", "image_prompt": "prompt"}]
            mock_topic.return_value = "Health Topic"
            mock_images.return_value = [] # No images generated in this mock
            mock_check_guest.return_value = {"allowed": True, "remaining": 2, "message_count": 0, "limit": 3, "guest_id": "guest_1"}
            mock_increment_guest.return_value = {"guest_id": "guest_1", "remaining": 2}

            client = TestClient(app)
            response = client.post(
                "/chat",
                json={"query": "How to treat a headache?", "generate_images": False}
            )

            assert response.status_code == 200
            data = response.json()
            assert "answer" in data
            assert data["answer"] == mock_answer

    def test_chat_includes_original_query(self):
        """Test that response includes original query."""
        from api_server import app

        with patch("api_server.check_input_safety") as mock_safety, \
             patch("api_server.check_output_safety") as mock_output_safety, \
             patch("api_server.invoke_llm") as mock_llm, \
             patch("api_server.extract_treatment_steps") as mock_steps, \
             patch("api_server.detect_medical_topic") as mock_topic, \
             patch("api_server.generate_all_step_images") as mock_images, \
             patch("api_server.check_guest_limit") as mock_check_guest, \
             patch("api_server.increment_guest_message") as mock_increment_guest, \
             patch("api_server.log_guest_event") as mock_log_guest:

            mock_safety.return_value = (True, "Test query", None)
            mock_output_safety.return_value = (True, "Answer", None)
            mock_llm.return_value = "Answer"
            mock_steps.return_value = []
            mock_topic.return_value = "Topic"
            mock_images.return_value = []
            mock_check_guest.return_value = {"allowed": True, "remaining": 2, "message_count": 0, "limit": 3, "guest_id": "guest_1"}
            mock_increment_guest.return_value = {"guest_id": "guest_1", "remaining": 2}

            client = TestClient(app)
            response = client.post(
                "/chat",
                json={"query": "Test query", "generate_images": False}
            )

            data = response.json()
            assert data["original_query"] == "Test query"

    def test_chat_saves_for_authenticated_user(self):
        """Test that chat is saved for authenticated users."""
        from api_server import app

        with patch("api_server.check_input_safety") as mock_safety, \
             patch("api_server.check_output_safety") as mock_output_safety, \
             patch("api_server.invoke_llm") as mock_llm, \
             patch("api_server.extract_treatment_steps") as mock_steps, \
             patch("api_server.detect_medical_topic") as mock_topic, \
             patch("api_server.generate_all_step_images") as mock_images, \
             patch("api_server.get_user_info") as mock_auth, \
             patch("api_server.save_chat") as mock_save, \
             patch("api_server.get_context_summary") as mock_context:

            mock_safety.return_value = (True, "Test query", None)
            mock_output_safety.return_value = (True, "Answer", None)
            mock_llm.return_value = "Answer"
            mock_steps.return_value = []
            mock_topic.return_value = "Topic"
            mock_images.return_value = []
            mock_auth.return_value = {"user_id": "user-123", "email": "test@test.com"}
            mock_save.return_value = {"chat_id": "chat-123"}
            mock_context.return_value = ""

            client = TestClient(app)
            response = client.post(
                "/chat",
                json={"query": "Test query", "generate_images": False},
                headers={"Authorization": "Bearer valid-token"}
            )

            assert response.status_code == 200
            mock_save.assert_called_once()

    def test_upload_url_requires_auth(self):
        """Test that upload URL requires authentication."""
        from api_server import app
        client = TestClient(app)

        response = client.post(
            "/upload-report",
            json={"filename": "test.pdf", "content_type": "application/pdf"}
        )

        assert response.status_code == 401

    def test_upload_url_validates_file_type(self):
        """Test that upload URL validates allowed file types."""
        from api_server import app

        with patch("api_server.get_user_info") as mock_auth:
            mock_auth.return_value = {"user_id": "user-123", "email": "test@test.com"}

            # Setup environment variable for reports bucket
            with patch.dict(os.environ, {"REPORTS_BUCKET": "test-bucket"}):
                client = TestClient(app)
                response = client.post(
                    "/upload-report",
                    json={"filename": "test.exe", "content_type": "application/x-executable"},
                    headers={"Authorization": "Bearer valid-token"}
                )

                # Should fail validation
                assert response.status_code in [400, 422]

    def test_generate_image_returns_base64(self):
        """Test that /generate-image returns base64 image data."""
        from api_server import app
        client = TestClient(app)

        with patch("api_server.generate_image") as mock_generate:
            mock_generate.return_value = b"image-bytes"

            response = client.post(
                "/generate-image",
                json={"prompt": "test", "width": 64, "height": 64}
            )

            assert response.status_code == 200
            data = response.json()
            assert data["image"] == base64.b64encode(b"image-bytes").decode("utf-8")


class TestChatGuestLimitHeaders:
    """Tests for guest limit using forwarded headers."""

    def test_chat_uses_forwarded_ip_and_fingerprint(self):
        from api_server import app

        with patch("api_server.check_input_safety") as mock_safety, \
             patch("api_server.check_output_safety") as mock_output_safety, \
             patch("api_server.invoke_llm") as mock_llm, \
             patch("api_server.should_generate_images") as mock_should_images, \
             patch("api_server.check_guest_limit") as mock_check, \
             patch("api_server.increment_guest_message") as mock_increment:

            mock_safety.return_value = (True, "Test query", None)
            mock_output_safety.return_value = (True, "Answer", None)
            mock_llm.return_value = "Answer"
            mock_should_images.return_value = False
            mock_check.return_value = {"allowed": True, "remaining": 2, "message_count": 0, "limit": 3, "guest_id": "guest_1"}
            mock_increment.return_value = {"guest_id": "guest_1", "remaining": 2}

            client = TestClient(app)
            response = client.post(
                "/chat",
                json={"query": "Test query", "generate_images": False},
                headers={
                    "X-Forwarded-For": "1.2.3.4, 5.6.7.8",
                    "User-Agent": "UA",
                    "X-Fingerprint": "fp"
                }
            )

            assert response.status_code == 200
            mock_check.assert_called_once_with(ip_address="1.2.3.4", user_agent="UA", fingerprint="fp")
            _, kwargs = mock_increment.call_args
            assert kwargs["ip_address"] == "1.2.3.4"
            assert kwargs["user_agent"] == "UA"
            assert kwargs["fingerprint"] == "fp"


class TestChatOutputSafety:
    """Tests for output safety enforcement."""

    def test_chat_blocks_unsafe_output(self):
        from api_server import app

        with patch("api_server.check_input_safety") as mock_safety, \
             patch("api_server.check_output_safety") as mock_output_safety, \
             patch("api_server.invoke_llm") as mock_llm, \
             patch("api_server.generate_all_step_images") as mock_images:

            mock_safety.return_value = (True, "Test query", None)
            mock_llm.return_value = "Unsafe response"
            mock_output_safety.return_value = (False, "", "Safe fallback")
            with patch("api_server.check_guest_limit") as mock_check_guest, \
                 patch("api_server.increment_guest_message") as mock_increment_guest, \
                 patch("api_server.log_guest_event") as mock_log_guest:
                mock_check_guest.return_value = {"allowed": True, "remaining": 2, "message_count": 0, "limit": 3, "guest_id": "guest_1"}
                mock_increment_guest.return_value = {"guest_id": "guest_1", "remaining": 2}

                client = TestClient(app)
                response = client.post(
                    "/chat",
                    json={"query": "Test query", "generate_images": True}
                )

                assert response.status_code == 200
                data = response.json()
                assert data["answer"] == "Safe fallback"
                assert data["steps_count"] == 0
                mock_images.assert_not_called()


class TestChatStepImagePersistence:
    """Tests step image fallback propagation and persistence."""

    def test_chat_propagates_fallback_and_s3_key(self):
        from api_server import app

        step_data = {
            "step_number": "1",
            "title": "Step 1",
            "description": "Do this",
            "image": None,
            "image_url": None,
            "s3_key": "steps/abc/step_1.png",
            "image_failed": True,
            "fallback_text": {
                "action": "A",
                "method": "M",
                "caution": "C",
                "result": "R"
            },
            "is_composite": False,
            "panel_index": None
        }

        with patch("api_server.check_input_safety") as mock_safety, \
             patch("api_server.check_output_safety") as mock_output_safety, \
             patch("api_server.invoke_llm") as mock_llm, \
             patch("api_server.should_generate_images") as mock_should, \
             patch("api_server.extract_treatment_steps") as mock_steps, \
             patch("api_server.generate_all_step_images") as mock_images, \
             patch("api_server.get_user_info") as mock_auth, \
             patch("api_server.save_chat") as mock_save, \
             patch("api_server.extract_facts_from_chat") as mock_extract_facts, \
             patch("api_server.get_context_summary") as mock_context:

            mock_safety.return_value = (True, "Test query", None)
            mock_output_safety.return_value = (True, "Answer", None)
            mock_llm.return_value = "Answer"
            mock_should.return_value = True
            mock_steps.return_value = [{"step_number": "1", "title": "Step 1", "description": "Do this"}]
            mock_images.return_value = [step_data]
            mock_auth.return_value = {"user_id": "user-123", "email": "test@test.com"}
            mock_extract_facts.return_value = []
            mock_context.return_value = ""

            client = TestClient(app)
            response = client.post(
                "/chat",
                json={"query": "Test query", "generate_images": True},
                headers={"Authorization": "Bearer valid-token"}
            )

            assert response.status_code == 200
            data = response.json()
            assert data["step_images"][0]["image_failed"] is True
            assert data["step_images"][0]["fallback_text"]["action"] == "A"

            _, kwargs = mock_save.call_args
            saved_steps = kwargs["step_images"]
            assert saved_steps[0]["s3_key"] == "steps/abc/step_1.png"
            assert saved_steps[0]["image_failed"] is True
            assert saved_steps[0]["fallback_text"]["action"] == "A"


class TestDeleteChatEndpoint:
    """Tests for DELETE /history/{chat_id} endpoint."""

    def test_delete_chat_requires_auth(self):
        """Test that delete chat requires authentication."""
        from api_server import app
        client = TestClient(app)

        response = client.delete("/history/chat-123")

        assert response.status_code == 401

    def test_delete_chat_deletes_for_owner(self):
        """Test that chat is deleted for authenticated owner."""
        from api_server import app

        with patch("api_server.get_user_info") as mock_auth:
            mock_auth.return_value = {"user_id": "user-123", "email": "test@test.com"}
            with patch("api_server.delete_chat") as mock_delete:
                mock_delete.return_value = True

                client = TestClient(app)
                response = client.delete(
                    "/history/chat-123",
                    headers={"Authorization": "Bearer valid-token"}
                )

                assert response.status_code == 200
                mock_delete.assert_called_once_with("user-123", "chat-123")
