"""
Audit Logging Module for MediBot
Records access and modification events for security and compliance.

Events are stored in DynamoDB with TTL for automatic cleanup.
"""

import os
import boto3
import json
import uuid
from typing import Dict, Any, Optional, List
from datetime import datetime, timedelta
from enum import Enum
from functools import wraps

# Environment variables
AUDIT_TABLE = os.getenv("AUDIT_TABLE", "medibot-audit-logs")
AWS_REGION = os.getenv("AWS_REGION", "us-east-1")
AUDIT_RETENTION_DAYS = int(os.getenv("AUDIT_RETENTION_DAYS", "90"))

# DynamoDB client (lazy init)
_dynamodb = None


def get_dynamodb():
    """Get or create DynamoDB resource."""
    global _dynamodb
    if _dynamodb is None:
        _dynamodb = boto3.resource('dynamodb', region_name=AWS_REGION)
    return _dynamodb


def get_table():
    """Get DynamoDB table."""
    return get_dynamodb().Table(AUDIT_TABLE)


# Event types
class AuditEvent:
    # Authentication events
    LOGIN_SUCCESS = "auth.login.success"
    LOGIN_FAILED = "auth.login.failed"
    LOGOUT = "auth.logout"
    TOKEN_REFRESH = "auth.token.refresh"

    # Data access events
    CHAT_CREATE = "chat.create"
    CHAT_READ = "chat.read"
    CHAT_DELETE = "chat.delete"
    HISTORY_LIST = "chat.history.list"

    # Health profile events
    PROFILE_CREATE = "profile.create"
    PROFILE_READ = "profile.read"
    PROFILE_UPDATE = "profile.update"
    PROFILE_DELETE = "profile.delete"

    # File events
    FILE_UPLOAD = "file.upload"
    FILE_ACCESS = "file.access"
    FILE_DELETE = "file.delete"
    REPORT_ANALYZE = "file.report.analyze"

    # Security events
    RATE_LIMIT_HIT = "security.rate_limit"
    INVALID_TOKEN = "security.invalid_token"
    SUSPICIOUS_ACTIVITY = "security.suspicious"

    # Guest events
    GUEST_CHAT = "guest.chat"
    GUEST_LIMIT_REACHED = "guest.limit_reached"


def log_event(
    event_type: str,
    user_id: Optional[str] = None,
    resource_id: Optional[str] = None,
    resource_type: Optional[str] = None,
    ip_address: Optional[str] = None,
    user_agent: Optional[str] = None,
    details: Optional[Dict[str, Any]] = None,
    severity: str = "info"
) -> Optional[str]:
    """
    Log an audit event to DynamoDB.

    Args:
        event_type: Type of event (use AuditEvent constants)
        user_id: User's Cognito sub ID (or "guest" for unauthenticated)
        resource_id: ID of affected resource (chat_id, profile_id, etc.)
        resource_type: Type of resource (chat, profile, file)
        ip_address: Client IP address
        user_agent: Client user agent string
        details: Additional event-specific details
        severity: info, warning, error, critical

    Returns:
        Event ID if logged successfully, None on error
    """
    now = datetime.utcnow()
    event_id = f"evt_{int(now.timestamp() * 1000)}_{uuid.uuid4().hex[:8]}"

    # Calculate TTL based on retention policy
    ttl = int((now + timedelta(days=AUDIT_RETENTION_DAYS)).timestamp())

    event = {
        "event_id": event_id,
        "timestamp": int(now.timestamp() * 1000),
        "event_type": event_type,
        "user_id": user_id or "anonymous",
        "resource_id": resource_id or "",
        "resource_type": resource_type or "",
        "ip_address": ip_address or "",
        "user_agent": (user_agent or "")[:500],  # Limit length
        "details": details or {},
        "severity": severity,
        "created_at": now.isoformat(),
        "ttl": ttl
    }

    try:
        table = get_table()
        table.put_item(Item=event)

        # Log to CloudWatch as well for real-time monitoring
        print(f"AUDIT [{severity.upper()}] {event_type} user={user_id or 'anon'} resource={resource_id or 'none'}")

        return event_id
    except Exception as e:
        print(f"Error logging audit event: {e}")
        return None


def log_chat_access(
    user_id: str,
    chat_id: str,
    action: str = "read",
    ip_address: Optional[str] = None
) -> Optional[str]:
    """Helper for logging chat access events."""
    event_type = {
        "read": AuditEvent.CHAT_READ,
        "create": AuditEvent.CHAT_CREATE,
        "delete": AuditEvent.CHAT_DELETE,
        "list": AuditEvent.HISTORY_LIST
    }.get(action, AuditEvent.CHAT_READ)

    return log_event(
        event_type=event_type,
        user_id=user_id,
        resource_id=chat_id,
        resource_type="chat",
        ip_address=ip_address
    )


def log_profile_access(
    user_id: str,
    action: str = "read",
    ip_address: Optional[str] = None,
    changes: Optional[Dict] = None
) -> Optional[str]:
    """Helper for logging health profile access events."""
    event_type = {
        "read": AuditEvent.PROFILE_READ,
        "create": AuditEvent.PROFILE_CREATE,
        "update": AuditEvent.PROFILE_UPDATE,
        "delete": AuditEvent.PROFILE_DELETE
    }.get(action, AuditEvent.PROFILE_READ)

    return log_event(
        event_type=event_type,
        user_id=user_id,
        resource_id=user_id,
        resource_type="health_profile",
        ip_address=ip_address,
        details={"changes": changes} if changes else None
    )


def log_file_event(
    user_id: str,
    file_key: str,
    action: str = "upload",
    file_type: Optional[str] = None,
    ip_address: Optional[str] = None
) -> Optional[str]:
    """Helper for logging file-related events."""
    event_type = {
        "upload": AuditEvent.FILE_UPLOAD,
        "access": AuditEvent.FILE_ACCESS,
        "delete": AuditEvent.FILE_DELETE,
        "analyze": AuditEvent.REPORT_ANALYZE
    }.get(action, AuditEvent.FILE_ACCESS)

    return log_event(
        event_type=event_type,
        user_id=user_id,
        resource_id=file_key,
        resource_type="file",
        ip_address=ip_address,
        details={"file_type": file_type} if file_type else None
    )


def log_security_event(
    event_type: str,
    ip_address: str,
    user_id: Optional[str] = None,
    details: Optional[Dict] = None,
    severity: str = "warning"
) -> Optional[str]:
    """Helper for logging security-related events."""
    return log_event(
        event_type=event_type,
        user_id=user_id,
        ip_address=ip_address,
        details=details,
        severity=severity
    )


def log_guest_event(
    guest_id: str,
    ip_address: str,
    action: str = "chat",
    details: Optional[Dict] = None
) -> Optional[str]:
    """Helper for logging guest events."""
    event_type = {
        "chat": AuditEvent.GUEST_CHAT,
        "limit_reached": AuditEvent.GUEST_LIMIT_REACHED
    }.get(action, AuditEvent.GUEST_CHAT)

    return log_event(
        event_type=event_type,
        user_id=f"guest:{guest_id}",
        ip_address=ip_address,
        details=details
    )


def get_user_audit_log(
    user_id: str,
    limit: int = 50,
    event_type: Optional[str] = None
) -> List[Dict[str, Any]]:
    """
    Get audit log entries for a specific user.

    Note: This requires a GSI on user_id for efficient queries.
    For now, uses scan with filter (not recommended for production scale).
    """
    try:
        table = get_table()

        filter_expr = "user_id = :uid"
        expr_values = {":uid": user_id}

        if event_type:
            filter_expr += " AND begins_with(event_type, :etype)"
            expr_values[":etype"] = event_type

        response = table.scan(
            FilterExpression=filter_expr,
            ExpressionAttributeValues=expr_values,
            Limit=limit
        )

        # Sort by timestamp descending
        items = response.get("Items", [])
        items.sort(key=lambda x: x.get("timestamp", 0), reverse=True)

        return items[:limit]
    except Exception as e:
        print(f"Error getting user audit log: {e}")
        return []


# Decorator for automatic audit logging
def audit_logged(event_type: str, resource_type: str = ""):
    """
    Decorator to automatically log function calls to audit log.

    Usage:
        @audit_logged(AuditEvent.PROFILE_READ, "health_profile")
        async def get_profile(request, authorization):
            ...
    """
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Try to extract user_id and resource_id from kwargs
            user_id = kwargs.get("user_id")
            resource_id = kwargs.get("resource_id") or kwargs.get("chat_id")

            # Log the event
            log_event(
                event_type=event_type,
                user_id=user_id,
                resource_id=resource_id,
                resource_type=resource_type
            )

            return await func(*args, **kwargs)
        return wrapper
    return decorator
